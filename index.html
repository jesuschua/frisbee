<!DOCTYPE html>
<html>
<head>
    <title>First Person Frisbee</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 18px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="crosshair"></div>
    <div id="hud">
        <div>Frisbees: <span id="frisbeeCount">10</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Power: <span id="power">100</span>%</div>
    </div>
    <div id="instructions">
        WASD: Move | Mouse: Look | Click: Throw | Hold Click: Charge Power
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Player properties
        let player = {
            x: 0,
            y: 0,
            z: 0,
            yaw: 0,    // horizontal rotation
            pitch: 0,  // vertical rotation
            speed: 0.5,
            power: 100,
            charging: false,
            chargeStart: 0
        };

        // Game state
        let frisbees = [];
        let targets = [];
        let keys = {};
        let score = 0;
        let frisbeeCount = 10;
        let mouseX = 0;
        let mouseY = 0;
        let isMouseLocked = false;

        // 3D environment
        const ground = -2;
        const skyColor = '#87CEEB';
        const groundColor = '#90EE90';

        // Initialize targets
        function createTargets() {
            for (let i = 0; i < 5; i++) {
                targets.push({
                    x: Math.random() * 40 - 20,
                    y: Math.random() * 2 - 1,
                    z: Math.random() * 30 + 10,
                    radius: 1,
                    hit: false,
                    color: '#FF0000'
                });
            }
        }

        // 3D math functions
        function project3D(x, y, z) {
            // Translate relative to player
            let dx = x - player.x;
            let dy = y - player.y;
            let dz = z - player.z;

            // Rotate by player yaw
            let rotX = dx * Math.cos(player.yaw) - dz * Math.sin(player.yaw);
            let rotZ = dx * Math.sin(player.yaw) + dz * Math.cos(player.yaw);
            let rotY = dy;

            // Apply pitch rotation
            let finalY = rotY * Math.cos(player.pitch) - rotZ * Math.sin(player.pitch);
            let finalZ = rotY * Math.sin(player.pitch) + rotZ * Math.cos(player.pitch);

            if (finalZ <= 0.1) return null; // Behind camera

            // Project to screen
            let scale = canvas.height / finalZ;
            return {
                x: canvas.width / 2 + rotX * scale,
                y: canvas.height / 2 + finalY * scale,
                scale: scale,
                distance: finalZ
            };
        }

        // Draw 3D environment
        function drawEnvironment() {
            // Sky gradient
            let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, skyColor);
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = groundColor;
            let groundProjected = project3D(0, ground, 50);
            if (groundProjected) {
                ctx.fillRect(0, groundProjected.y, canvas.width, canvas.height - groundProjected.y);
            }

            // Draw grid on ground
            ctx.strokeStyle = 'rgba(0, 100, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let x = -50; x <= 50; x += 5) {
                let start = project3D(x, ground, 0);
                let end = project3D(x, ground, 50);
                if (start && end) {
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            }
            for (let z = 0; z <= 50; z += 5) {
                let start = project3D(-50, ground, z);
                let end = project3D(50, ground, z);
                if (start && end) {
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            }
        }

        // Draw targets
        function drawTargets() {
            targets.forEach(target => {
                if (target.hit) return;
                
                let projected = project3D(target.x, target.y, target.z);
                if (projected) {
                    let radius = target.radius * projected.scale;
                    
                    // Target rings
                    ctx.fillStyle = target.color;
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radius * 0.7, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radius * 0.4, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            });
        }

        // Draw frisbees
        function drawFrisbees() {
            frisbees.forEach((frisbee, index) => {
                let projected = project3D(frisbee.x, frisbee.y, frisbee.z);
                if (projected) {
                    let radius = 0.3 * projected.scale;
                    
                    ctx.save();
                    ctx.translate(projected.x, projected.y);
                    ctx.rotate(frisbee.rotation);
                    ctx.scale(1, Math.cos(frisbee.tilt));
                    
                    // Frisbee body
                    let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    gradient.addColorStop(0, '#FFD700');
                    gradient.addColorStop(0.7, '#FFA500');
                    gradient.addColorStop(1, '#FF8C00');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Rotation indicator
                    ctx.strokeStyle = '#DC143C';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-radius * 0.8, 0);
                    ctx.lineTo(radius * 0.8, 0);
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                // Remove frisbees that are too far or hit ground
                if (frisbee.z > 100 || frisbee.y < ground) {
                    frisbees.splice(index, 1);
                }
            });
        }

        // Update frisbee physics
        function updateFrisbees() {
            frisbees.forEach(frisbee => {
                frisbee.x += frisbee.velocityX;
                frisbee.y += frisbee.velocityY;
                frisbee.z += frisbee.velocityZ;
                
                // Physics
                frisbee.velocityY -= 0.02; // gravity
                frisbee.velocityX *= 0.995; // air resistance
                frisbee.velocityZ *= 0.995;
                
                // Rotation
                frisbee.rotation += frisbee.rotationSpeed;
                frisbee.tilt += frisbee.tiltSpeed;
                frisbee.tiltSpeed *= 0.98;
                
                // Check target collisions
                targets.forEach(target => {
                    if (target.hit) return;
                    let dx = frisbee.x - target.x;
                    let dy = frisbee.y - target.y;
                    let dz = frisbee.z - target.z;
                    let distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (distance < target.radius + 0.3) {
                        target.hit = true;
                        score += 100;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
        }

        // Handle player movement
        function updatePlayer() {
            if (keys['w'] || keys['W']) {
                player.x += Math.sin(player.yaw) * player.speed;
                player.z += Math.cos(player.yaw) * player.speed;
            }
            if (keys['s'] || keys['S']) {
                player.x -= Math.sin(player.yaw) * player.speed;
                player.z -= Math.cos(player.yaw) * player.speed;
            }
            if (keys['a'] || keys['A']) {
                player.x -= Math.cos(player.yaw) * player.speed;
                player.z += Math.sin(player.yaw) * player.speed;
            }
            if (keys['d'] || keys['D']) {
                player.x += Math.cos(player.yaw) * player.speed;
                player.z -= Math.sin(player.yaw) * player.speed;
            }
            
            // Update power charging
            if (player.charging) {
                let chargeTime = Date.now() - player.chargeStart;
                player.power = Math.min(200, 50 + chargeTime / 10);
                document.getElementById('power').textContent = Math.floor(player.power);
            }
        }

        // Throw frisbee
        function throwFrisbee() {
            if (frisbeeCount <= 0) return;
            
            frisbeeCount--;
            document.getElementById('frisbeeCount').textContent = frisbeeCount;
            
            let power = player.power / 100;
            
            frisbees.push({
                x: player.x,
                y: player.y,
                z: player.z,
                velocityX: Math.sin(player.yaw) * Math.cos(player.pitch) * power * 0.3,
                velocityY: Math.sin(player.pitch) * power * 0.3,
                velocityZ: Math.cos(player.yaw) * Math.cos(player.pitch) * power * 0.3,
                rotation: 0,
                rotationSpeed: power * 0.2,
                tilt: 0,
                tiltSpeed: Math.random() * 0.1 - 0.05
            });
            
            player.power = 100;
            player.charging = false;
            document.getElementById('power').textContent = player.power;
        }

        // Event listeners
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        canvas.addEventListener('mousedown', e => {
            if (!isMouseLocked) {
                canvas.requestPointerLock();
            } else {
                player.charging = true;
                player.chargeStart = Date.now();
            }
        });

        canvas.addEventListener('mouseup', e => {
            if (player.charging) {
                throwFrisbee();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isMouseLocked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', e => {
            if (isMouseLocked) {
                player.yaw += e.movementX * 0.003;
                player.pitch += e.movementY * 0.003;
                player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game loop
        function gameLoop() {
            updatePlayer();
            updateFrisbees();
            
            drawEnvironment();
            drawTargets();
            drawFrisbees();
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize and start
        createTargets();
        gameLoop();
    </script>
</body>
</html>